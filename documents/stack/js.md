# JS 특징

## 함수도 객체 취급한다.
사실 파이썬도 마찬가지긴 한데, 어째서인지 파이썬에서는 함수를 객체로 넘겨줄 일이 별로 없더라구요.

JS에선 callback 함수처럼 함수를 객체로 주고받는일이 상당히 많으니깐 잘 알고 계셔야 합니다.

```javascript
function functionIsObject() {
    console.log("Hello World!");
}

function runFunc(func) {
    func();
}

runFunc(functionIsObject);

// 실행결과: Hello World!
```

위의 소스 코드를 보면, runFunc 라는 함수에 functionIsObject 라는 함수를 인자로 넘겨줫죠?

함수를 인자로 넘겨줄 때 괄호를 없이 넘겨주면 그 함수의 리턴값을 보내는게 아닌, 그 함수 자체를 넘겨주게 됩니다.

runFunc 함수 내부에서는 func() 를 통해서 인자를 통해 받아온 함수를 실행시키고 있죠.

이런식으로 JS에선 인자를 통해 함수를 넘겨주는걸 자주 사용하게 될 거니깐 알아두세요.


## 화살표 함수
위에서 JS에선 인자를 통해 함수 자체를 넘겨주는걸 자주 사용하게 될 것이라고 했죠?

그 이유가 바로 이 화살표 함수 때문이에요.

```javascript

const arrFunc = (arg1) => {
    console.log(arg1);
}

arrFunc("Hello World!");

// 실행 결과: Hello World!
```

위를 보면 뭔가 함수를 이상하게 선언하고 있죠?

JS에선 함수를 객체 취급한다는 것과 화살표 함수라는것이 합쳐지면 저런 식으로 함수를 선언할 수 있어요.

우선, 화살표 함수의 모양은 다음과 같습니다
```
(인자1, 인자2, ...) => { 함수 내부 }
```

맨 위의 예제에서 (arg1) => {console.log(arg1)} 부분이 바로 화살표 함수이지요.

function(arg1) {console.log(arg1)} 과 위의 화살표 함수는 완전히 같은 뜻이에요.

그냥 JS에선 함수를 저렇게도 표현할 수 있다고 알아두세요.

추가로, 맨 위의 예제는 arrFunc 라는 변수에 화살표 함수를 할당해주는 모습이에요.

JS에선 함수가 객체 취급이기 때문에 인자로 넘겨주는거 말고도 변수에 넣어 줄 수도 있어요


## 익명 함수 (화살표함수 심화)

위의 두 예제를 통해 JS에선 함수 인자에 함수를 객체로 넘겨줄 수 있는 것과, 화살표 함수로 함수를 특이하게 선언할 수 있다는것을 알게 되었습니다.

이러한 점 때문에 JS에선 아래와 같은 형식의 코드를 자주 만나게 될 거에요.

```javascript

const runAnonymousFunc = (func) => {
    func();
}

runAnonymousFunc( () => { console.log("Hello World!") } );

// 실행 결과: Hello World!
```

음... 뭔가 지금까지 나온게 중첩해서 나오니깐 정신없죠?

runAnonymousFunc 함수 인자에 화살표 함수를 선언과 동시에 넣어줬어요.

이렇게 따로 함수명 없이 즉시 실행/인자로 넘겨주는 함수를 익명 함수라고 해요.

몇번이고 다시 말하지만, JS에선 이런식으로 함수 인자에 익명 화살표함수를 넘겨주는 모습을 굉장히 자주 만나게 될 테니깐, 익숙해지는게 좋아요.

## Callback Function
위에서 여러번 한 것처럼, 함수 인자를 통해 보내주게되는 함수를 콜백 함수라고 불러요.

정확히는 이렇게 인자로 보내준 함수를 그 함수 내부에서 실행까지 시켜야 콜백함수라고 부르는데,
대부분의 인자로 넘겨주는 함수는 실행되니깐 아마 대충 불러도 괜찮을거에요.

JS에서 왜이렇게 콜백함수를 사용하냐고 하면 JS의 특징중 하나인 비동기 실행 때문인데요.

JS에서의 비동기/동기 처리에 대해서 이야기하면 굉장히 길어지고 복잡하니깐 나중에 스스로 찾아보는걸 추천드려요.

## Callback Hell
이런 콜백 함수를 생각없이 코딩하면 콜백함수 내부에 콜백함수가 여러번 중첩해서 들어가게 될 수도 있어요.

이게 딱히 나쁘다는건 아닌데, 이렇게 콜백함수 중첩이 심해지게 되면 코드 가독성이 굉장히 떨어지고 더러운 코드가 되요.

이렇게 콜백이 여러번 중첩되서 코드 가독성이 떨어지는걸 콜백 헬이라고 불러요.

아래는 극단적인 콜백 헬의 예제에요.
![image](https://miro.medium.com/max/721/0*C0iEvjGNPURJcqrI.jpeg)

## Promise
위의 콜백 헬을 처리하기 위해 나온게 async/await 함수와 Promise에요.

이것도 비동기/동기 실행 관련한 이야기라 자세히 들어가면 복잡해지니깐 살짝 문법만 살펴보도록 해요.

```javascript

const doSuperHeavyJob = (arg1) => {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve("hello world!");
        }, 1000*10);        // 실행에 10초 걸리는 슈퍼 무거운 함수
    });
}

const runAsyncFunc = async (func) => {      // async 함수로 선언
    const result = await func();       // func를 await 하게 실행 (func 함수가 실행이 끝날 떄까지 기다려줌)
    console.log(result);
}

runAsyncFunc(doSuperHeavyJob);

// 실행 결과: hello world!
```

대충 async 로 선언된 함수 내부에서는,
자신처럼 똑같이 async로 선언된 함수나, Promise를 반환하는 함수를 
await으로 기다려줄 수 있어요.

JS는 작동 방식이 특이해서, "기본적으로는" 코드를 순차적으로 실행하는데,
중간에 시간이 오래 걸리는 함수를 만난 경우,
오래 걸리는 작업을 async/await 처리하거나, callback 함수를 이용하지 않으면, 
그 함수를 띄어넘어서 더 아래에 있는 코드를 바로 실행시켜버려요.

이게 JS가 인터프리터 언어임에도 불구하고 빠른 속도를 유지할 수 있는 이유인데,
프로그래머 입장에서는 함수가 순서대로 실행되지 않으니깐 무거운 함수를 사용하려면 골치가 아프지죠.

이걸 위해서 callback 함수를 이용했는데, 저 위에서처럼 이걸 남발하다보니깐 끔찍한 코드가 탄생했어요.

그걸 막기 위해서 Promise, await/async가 생긴거에요.


대충 JS 관련해서는 이정도면 될 거에요. 나머지는 직접 공부해보시길 바래요.

저 개인적으로는 파이썬보다 자바스크립트랑 타입스크립트를 더 많이 사용하니깐 질문 있으면 마음껏 질문해주셔도 괜찮아요.

그럼, 실제로 구현할때 힘내세요!
